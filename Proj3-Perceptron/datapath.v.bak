module datapath(clk, ld_N, clr_N, ld_Ep, clr_Ep, ld_w, clr_w, ld_e, clr_e, Epm, Nm, w0, w1, EPOCAS);
   // Declaração de portas
   input clk, EPOCAS/*comandos*/  ld_N, clr_N, ld_Ep, clr_Ep, ld_w, clr_w, ld_e, clr_e;
   output reg /*status*/ Epm, Nm;
   output reg signed [7:0] w0, w1; // saida w0 e w1 de 8 bits
   
   reg [3:0] N, EP; 		// contador da tabela (N) e epoca (E)
   integer soma;    		// resultado da soma ponderada das entradas e pesos
   reg signed [1:0] y_pred;      		// predicao da saida do perceptron
   reg signed [1:0] Erro;	// erro = y - ŷ
   
   reg [1:0] x [3:0];		// x1 x0 ==> 00, 01, 10, 11
   reg signed [1:0] y_target [3:0];		// y => 0, 1, 1, 1

   parameter [31:0] limiar_funcao_ativacao = 32'd1;
   
   always @(*) begin
   
   //Mandar sinais de status caso epocas e/ou amostras tenham terminados
   
      // Controle de inicio e fim de epoca (EP)- EPOCAS = 4'd12;
      if (EP < EPOCAS ) begin
            epm <= 1'b1;
      end
      else begin 
            epm <= 1'b0;
      end
      // Controle de contador de tabela (N)
      
      if (N < 4) begin 
            nm <= 1'b1;
      end
      else begin 
        nm <= 1'b0;
        end
   
   end
   
   
   always @(posedge clk) begin
      if ( /*comando de iniciar o contador de tabela N */ ) begin
	 // Porta logica OR -> limiar = 1
	 /*x[0] <= 2'b00; y_target[0] <= 1'b0;
	 x[1] <= 2'b01; y_target[1] <= 1'b1;
	 x[2] <= 2'b10; y_target[2] <= 1'b1;
	 x[3] <= 2'b11; y_target[3] <= 1'b1;*/
	 x[0] <= 2'b00; y_target[0] <= 2'sd0;
	 x[1] <= 2'b01; y_target[1] <= 2'sd1;
	 x[2] <= 2'b10; y_target[2] <= 2'sd1;
	 x[3] <= 2'b11; y_target[3] <= 2'sd1;
      end
      
      /*Insere aqui os demais calculos*/
      if (clr_N) begin 
      N <= 4'd0;
      end
      else if (ld_N) begin 
            N <= N + 4'd1;
      end
      
      
      if (clr_Ep) begin 
            Ep <= 4'd0;
      end
      else if (ld_Ep) begin 
            Ep <= Ep + 4'd1;
      end
      
      
      if (clr_e) begin 
            e <= 2'd0;
      end
      else if (ld_e) begin 
            y_pred <= ( soma >= 1) ? 2'sd1 : 2'sd0; 
+    	    Erro <= y_target[N] - y_pred;
      end
     
      
      if (clr_w) begin 
            w <= 8'd0;
      end
      else if (ld_w) begin 
            w0 <= w0 + (Erro * X[N][0]) ; //taxa de aprendizagem de 1.;
            w1 <= w1 + (Erro * X[N][1]) ;
      end
      
      
     
    /*multiplicador, comparador de n e ep, 
    comparador do limiar, 
    somador, subtrator com if para complemento de 2 */
    
    
   end
   
endmodule
